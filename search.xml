<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot整合redis组件</title>
      <link href="/posts/c0ba78a5.html"/>
      <url>/posts/c0ba78a5.html</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合redis组件"><a href="#SpringBoot整合redis组件" class="headerlink" title="SpringBoot整合redis组件"></a>SpringBoot整合redis组件</h2><blockquote><p><code>不要跟过去的自己比，要期待未来的自己，珍爱现在的自己</code></p></blockquote><h3 id="1-添加Redis相关依赖"><a href="#1-添加Redis相关依赖" class="headerlink" title="1.添加Redis相关依赖"></a>1.添加Redis相关依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--Redis相关依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="2-application-properties中redis相关配置"><a href="#2-application-properties中redis相关配置" class="headerlink" title="2.application.properties中redis相关配置"></a>2.<strong>application.properties中redis相关配置</strong></h3><pre class=" language-xml"><code class="language-xml"># Redis数据库索引（默认为0）spring.redis.database=0  # Redis服务器地址spring.redis.host=127.0.0.1# Redis服务器连接端口spring.redis.port=6379  # Redis服务器连接密码（默认为空）spring.redis.password=# 连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=200 # 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1# 连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=10 # 连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=10 # 连接超时时间（毫秒）spring.redis.timeout=1000</code></pre><h3 id="3-redis自定义配置"><a href="#3-redis自定义配置" class="headerlink" title="3.redis自定义配置"></a>3.redis自定义配置</h3><blockquote><p>SpringBoot自动在容器中生成了一个<code>RedisTemplate</code>和一个<code>StringRedisTemplate</code></p></blockquote><p> 第一种：（添加方式添加配置）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRedisConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**      * 修改默认序列化得方式为Json解析    **/</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Employee<span class="token operator">></span> <span class="token function">empRedisTemplate</span><span class="token punctuation">(</span>            RedisConnectionFactory redisConnectionFactory<span class="token punctuation">)</span>            <span class="token keyword">throws</span> UnknownHostException <span class="token punctuation">{</span>        RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Employee<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Employee<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        Jackson2JsonRedisSerializer<span class="token operator">&lt;</span>Employee<span class="token operator">></span> ser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token operator">&lt;</span>Employee<span class="token operator">></span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setDefaultSerializer</span><span class="token punctuation">(</span>ser<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Department<span class="token operator">></span> <span class="token function">deptRedisTemplate</span><span class="token punctuation">(</span>            RedisConnectionFactory redisConnectionFactory<span class="token punctuation">)</span>            <span class="token keyword">throws</span> UnknownHostException <span class="token punctuation">{</span>        RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Department<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Department<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        Jackson2JsonRedisSerializer<span class="token operator">&lt;</span>Department<span class="token operator">></span> ser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token operator">&lt;</span>Department<span class="token operator">></span><span class="token punctuation">(</span>Department<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setDefaultSerializer</span><span class="token punctuation">(</span>ser<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//CacheManagerCustomizers可以来定制缓存的一些规则</span>    <span class="token annotation punctuation">@Primary</span>  <span class="token comment" spellcheck="true">//将某个缓存管理器作为默认的</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RedisCacheManager <span class="token function">employeeCacheManager</span><span class="token punctuation">(</span>RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Employee<span class="token operator">></span> empRedisTemplate<span class="token punctuation">)</span><span class="token punctuation">{</span>        RedisCacheManager cacheManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisCacheManager</span><span class="token punctuation">(</span>empRedisTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//key多了一个前缀</span>        <span class="token comment" spellcheck="true">//使用前缀，默认会将CacheName作为key的前缀</span>        cacheManager<span class="token punctuation">.</span><span class="token function">setUsePrefix</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cacheManager<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RedisCacheManager <span class="token function">deptCacheManager</span><span class="token punctuation">(</span>RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Department<span class="token operator">></span> deptRedisTemplate<span class="token punctuation">)</span><span class="token punctuation">{</span>        RedisCacheManager cacheManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisCacheManager</span><span class="token punctuation">(</span>deptRedisTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//key多了一个前缀</span>        <span class="token comment" spellcheck="true">//使用前缀，默认会将CacheName作为key的前缀</span>        cacheManager<span class="token punctuation">.</span><span class="token function">setUsePrefix</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cacheManager<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> 第二种：（重写redisTemplate）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectMapper om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>PropertyAccessor<span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> JsonAutoDetect<span class="token punctuation">.</span>Visibility<span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span>ObjectMapper<span class="token punctuation">.</span>DefaultTyping<span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>        StringRedisSerializer stringRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// key采用String的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash的key也采用String的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// value序列化方式采用jackson</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash的value序列化方式采用jackson</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象和Map转换</title>
      <link href="/posts/b59ed7a2.html"/>
      <url>/posts/b59ed7a2.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java对象和Map转换"><a href="#Java对象和Map转换" class="headerlink" title="Java对象和Map转换"></a>Java对象和Map转换</h2><blockquote><p><code>或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前路</code></p></blockquote><hr><h3 id="1-将Javabean对象装换为map"><a href="#1-将Javabean对象装换为map" class="headerlink" title="1. 将Javabean对象装换为map"></a>1. 将Javabean对象装换为map</h3><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">/**         * @param bean         * @return         */</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">beanToMap</span><span class="token punctuation">(</span>T bean<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                BeanMap beanMap <span class="token operator">=</span> BeanMap<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Object key <span class="token operator">:</span> beanMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">,</span> beanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> map<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><h3 id="2-将map装换为Javabean对象"><a href="#2-将map装换为Javabean对象" class="headerlink" title="2.将map装换为Javabean对象"></a>2.将map装换为Javabean对象</h3><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">/**         * @param map         * @param bean         * @return         */</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">mapToBean</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map<span class="token punctuation">,</span> T bean<span class="token punctuation">)</span> <span class="token punctuation">{</span>            BeanMap beanMap <span class="token operator">=</span> BeanMap<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>            beanMap<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> bean<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><h3 id="3-将List转换为List-lt-Map-lt-String-Object-gt-gt"><a href="#3-将List转换为List-lt-Map-lt-String-Object-gt-gt" class="headerlink" title="3.将List转换为List&lt;Map&lt;String, Object&gt;&gt;"></a>3.将List<T>转换为List&lt;Map&lt;String, Object&gt;&gt;</h3><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">/**         * @param objList         * @return         * @throws JsonGenerationException         * @throws JsonMappingException         * @throws IOException         */</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">>></span> <span class="token function">objectsToMaps</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> objList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">>></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>objList <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> objList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> null<span class="token punctuation">;</span>                T bean <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> objList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    bean <span class="token operator">=</span> objList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    map <span class="token operator">=</span> <span class="token function">beanToMap</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><h3 id="4-将List-lt-Map-lt-String-Object-gt-gt-转换为List"><a href="#4-将List-lt-Map-lt-String-Object-gt-gt-转换为List" class="headerlink" title="4. 将List&lt;Map&lt;String,Object&gt;&gt;转换为List"></a>4. 将List&lt;Map&lt;String,Object&gt;&gt;转换为List<T></h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**         * @param maps         * @param clazz         * @return         * @throws InstantiationException         * @throws IllegalAccessException       */</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">mapsToObjects</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">>></span> maps<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> clazz<span class="token punctuation">)</span>                <span class="token keyword">throws</span> InstantiationException<span class="token punctuation">,</span> IllegalAccessException <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>T<span class="token operator">></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maps <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> maps<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> null<span class="token punctuation">;</span>                T bean <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    map <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    bean <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">mapToBean</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>…</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的五种json库及操作</title>
      <link href="/posts/d5737b81.html"/>
      <url>/posts/d5737b81.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="Java的五种json库及操作"><a href="#Java的五种json库及操作" class="headerlink" title="Java的五种json库及操作"></a>Java的五种json库及操作</h2><blockquote><p><code>你的所言所行，全都闪烁着光芒，太过刺目，于是我闭上双眼，但内心还是无法停止对你的憧憬</code></p></blockquote><p>​    Java 中json格式的字符串写法 </p><pre><code>String paramess=&quot;{\&quot;name\&quot;:\&quot;Mahesh\&quot;,\&quot;password\&quot;:21}&quot;;</code></pre><h3 id="1-json-lib"><a href="#1-json-lib" class="headerlink" title="1. json-lib"></a>1. json-lib</h3><blockquote><p>json-lib具有通用性，但是比较麻烦，且时间有些久远，jar包只更新到2010年</p><p>项目地址：<a href="http://json-lib.sourceforge.net/index.html" target="_blank" rel="noopener">http://json-lib.sourceforge.net/index.html</a></p></blockquote><h5 id="1-1-maven依赖"><a href="#1-1-maven依赖" class="headerlink" title="1.1 maven依赖"></a>1.1 maven依赖</h5><pre><code>&lt;dependency&gt;    &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;    &lt;artifactId&gt;json-lib&lt;/artifactId&gt;    &lt;version&gt;2.4&lt;/version&gt;    &lt;classifier&gt;jdk15&lt;/classifier&gt;//jar包区分jdk1.3和jdk1.5版本&lt;/dependency&gt;</code></pre><h5 id="1-2-具体操作"><a href="#1-2-具体操作" class="headerlink" title="1.2 具体操作"></a>1.2 具体操作</h5><ul><li><p>1.2.1 JSONObject与String相互转换</p><pre><code>  JSONObject jsonobject= JSONObject.fromObject(str);  String str = JSONObject.toString</code></pre></li><li><p>1.2.2 获取JSONObject数据及遍历JSONArray</p><p>  String str = JSONObject.getInt(“keys”)<br>  String str = JSONObject.getString(“keys”)<br>  JSONArray = JSONObject.getJSONArray(String);</p></li><li><p>遍历：</p><pre><code>  for(i&lt;JSONArray.size())  {     JSONObject = JSONArray.getJSONObject(i);      JSONObject.getInt()...  }  Iterator&lt;String&gt; iterator = JSONObject.keys();     while(iterator.hasNext()){      String keys = iterator.next();  }</code></pre></li><li><p>1.2.2 JSONObject转对象</p><pre><code>  Grade grade = (Grade)JSONObject.toBean(jsonObject,Grade.class);</code></pre></li></ul><h3 id="2-org-json"><a href="#2-org-json" class="headerlink" title="2.org.json"></a>2.org.json</h3><blockquote><p>与json-lib相类似</p></blockquote><h5 id="2-1maven依赖"><a href="#2-1maven依赖" class="headerlink" title="2.1maven依赖"></a>2.1maven依赖</h5><pre><code>    &lt;dependency&gt;          &lt;groupId&gt;org.json&lt;/groupId&gt;          &lt;artifactId&gt;json&lt;/artifactId&gt;          &lt;version&gt;20170516&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h5 id="2-2-创建json对象"><a href="#2-2-创建json对象" class="headerlink" title="2.2 创建json对象"></a>2.2 创建json对象</h5><pre><code>    JSONObject = new JSONObject(str);</code></pre><h5 id="2-3-操作"><a href="#2-3-操作" class="headerlink" title="2.3 操作"></a>2.3 操作</h5><pre><code>net.sf.json.JSONObject： 没有严格要求获取字段的类型跟getXXX()的类型一样org.json.JSONObject：获取的字段类型必须跟getXXX()的类型一样</code></pre><h5 id="2-4-JSONArray-length"><a href="#2-4-JSONArray-length" class="headerlink" title="2.4 JSONArray.length()"></a>2.4 JSONArray.length()</h5><h3 id="3-jackSon"><a href="#3-jackSon" class="headerlink" title="3. jackSon"></a>3. jackSon</h3><blockquote><p>springMVC内置解析器就是jackson </p><p>项目地址：<a href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener">https://github.com/FasterXML/jackson</a></p></blockquote><h5 id="3-1-maven依赖"><a href="#3-1-maven依赖" class="headerlink" title="3.1 maven依赖"></a>3.1 maven依赖</h5><pre><code>    &lt;dependency&gt;          &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;          &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;          &lt;version&gt;2.9.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h5 id="3-2-对象和String之间的转换"><a href="#3-2-对象和String之间的转换" class="headerlink" title="3.2 对象和String之间的转换"></a>3.2 对象和String之间的转换</h5><pre><code>    ObjectMapper mapper=new ObjectMapper();    //json转对象    Grade grade=mapper.readValue(json1, Grade.class);    //对象转json    mapper.writeValueAsString(grade);</code></pre><h5 id="3-3-对JsonNode的遍历"><a href="#3-3-对JsonNode的遍历" class="headerlink" title="3.3 对JsonNode的遍历"></a>3.3 对JsonNode的遍历</h5><pre><code>    JsonNode jsonNode = mapper.readTree(jsonStr);    Iterator&lt;String&gt; keys = jsonNode.fieldNames();    while(keys.hasNext()){        String fieldName = keys.next();        System.out.println(fieldName + &quot; : &quot; + jsonNode.path(fieldName).toString());    }</code></pre><h3 id="4-fastjson"><a href="#4-fastjson" class="headerlink" title="4. fastjson"></a>4. fastjson</h3><blockquote><p>阿里巴巴开源框架，效率最高</p><p>项目地址：<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a></p></blockquote><h5 id="4-1-maven依赖"><a href="#4-1-maven依赖" class="headerlink" title="4.1 maven依赖"></a>4.1 maven依赖</h5><pre><code>    &lt;dependency&gt;          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;          &lt;artifactId&gt;fastjson&lt;/artifactId&gt;          &lt;version&gt;1.2.37&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h5 id="4-2-String转对象"><a href="#4-2-String转对象" class="headerlink" title="4.2 String转对象"></a>4.2 String转对象</h5><pre><code>    Student stu = JSON.parseObject(json,Student.class);    List&lt;String&gt; list=JSON.parseArray(json2, String.class);</code></pre><h5 id="4-3-对象转String"><a href="#4-3-对象转String" class="headerlink" title="4.3 对象转String"></a>4.3 对象转String</h5><pre><code>    JSON.toJSONString(stu);    //or String json = JSON.toJSON(stu).toString();</code></pre><h3 id="5-GSON"><a href="#5-GSON" class="headerlink" title="5.GSON"></a>5.GSON</h3><blockquote><p>谷歌产品 ，前功能最全</p><p>项目地址：<a href="https://github.com/google/gson" target="_blank" rel="noopener">https://github.com/google/gson</a></p></blockquote><h5 id="5-1-maven依赖"><a href="#5-1-maven依赖" class="headerlink" title="5.1 maven依赖"></a>5.1 maven依赖</h5><pre><code>    &lt;dependency&gt;          &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;          &lt;artifactId&gt;gson&lt;/artifactId&gt;          &lt;version&gt;2.8.1&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h5 id="5-2-String转对象"><a href="#5-2-String转对象" class="headerlink" title="5.2 String转对象"></a>5.2 String转对象</h5><pre><code>    Gson gson = new Gson();    Grade grade = gson.fromJson(json1,Grade.class);    ArrayList&lt;String&gt; list=gson.fromJson(json2,new TypeToken&lt;ArrayList&lt;String&gt;&gt;(){}.getType());</code></pre><h5 id="5-3-对象转String"><a href="#5-3-对象转String" class="headerlink" title="5.3 对象转String"></a>5.3 对象转String</h5><pre><code>    String json=gson.toJson(grade);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的常用命令类型和配置详解</title>
      <link href="/posts/6996938c.html"/>
      <url>/posts/6996938c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis的常用命令类型和配置详解"><a href="#Redis的常用命令类型和配置详解" class="headerlink" title="Redis的常用命令类型和配置详解"></a>Redis的常用命令类型和配置详解</h2><blockquote><p><code>苦恼着，歇斯底里着，痛苦着，不断挣扎的数月时间，这一切会在未来的某一瞬间得到回报。我们或许就是被那个瞬间迷住的，一种无可救药的生物吧</code></p></blockquote><h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><pre><code>keys* 查看当前库全部keysexists key 判断某个key是否存在move key db 移动当前库的key到别的库expire key 秒钟  设置给定的key设置过期时间ttl key 查看剩余多少秒过期，-1表示永不过期，-2表示已过期type key 查看你的key是什么类型</code></pre><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><pre><code>set/get/del/append/strlen 设置/获取/删除/在值后追加/值的长度Incr/decr/incrby/decrby，加/减/加多少/减多少 必须为数字getrange/setrange 获取值的范围/设置范围的值为什么setex（set with expire）键秒值/setnx（set if not exist）[key] [time] [value] 设置带有效期的键值对/不存在同名键时添加mset/mget/msetnx 同时多个键值对 设置/添加/不存在添加（只要一个存在都不执行）</code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>lpush/rpush/lrange 左边入栈/右边入栈/获取范围的值（0 -1 为获取全部）lpop/rpop 尾部出栈/头部出栈lindex 按照索引下标获得元素（从上到下）llen 获取list值长度lrem key n value 删N个值Itrim key 开始index 结束index  截取指定范围的值后再赋值给key rpoplpush 源key 目的key  从源list的头部出栈一位到目的list左边入栈lset key index value 设置索引位的值linsert key before/after 值1 值2  在某个值前或后插入值</code></pre><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><blockquote><p>zset 和 set 基本一样，不同的是zset 都会关联一个double类型的-score(分数)</p></blockquote><pre><code>sadd/smembers/sismember 添加/查询所有/查询是否存在scard 获取集合里元素个数srem key value 删除集合中元素srandmember key [n]  随机出n个数spop key 随机出栈smove key1 key2    将key1里的某个值移动到key2sdiff/sinter/sunion key1 key2    比较两key的差值/交集/并集</code></pre><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><pre><code>hset/hget/hmset/hmget/hgetall/hdel 插入/获取/多插入/多获取/获取全部/删除hlen 获取长度hexists key  在key里面的某个值判断key是否存在hkeys/hvals  获取全部key/获取全部valuehincrby/hincrbyfloat [n] 增加n值hsetnx 插入（不存在时）</code></pre><h3 id="二、常见配置redis-conf介绍"><a href="#二、常见配置redis-conf介绍" class="headerlink" title="二、常见配置redis.conf介绍"></a>二、常见配置redis.conf介绍</h3><pre><code>redis.conf 配置项说明如下：    1.Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程         daemonize no    2.当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定        pidfile/var/run/redis.pid    3.指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字        port 6379    4.绑定的主机地址        bind 127.0.0.1    5.当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能        timeout 300    6.指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose         loglevel verbose    7.日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null         logfile stdout    8.设置数据库的数量，默认数据库为0，可以使用SELECT&lt;dbid&gt;命令在连接上指定数据库id         databases 16    9.指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合        save &lt;seconds&gt;&lt;changes&gt;    Redis默认配置文件中提供了三个条件：        save 9001        save 30010        save 6010000分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。    10.指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大        rdbcompression yes    11.指定本地数据库文件名，默认值为dump.rdb         dbfilename dump.rdb    12.指定本地数据库存放目录        dir./    13.设置当本机为lav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步        slaveof &lt;masterip&gt;&lt;masterport&gt;    14.当master服务设置了密码保护时，slav服务连接master的密码        masterauth &lt;master-password&gt;    15.设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭        requirepass foobared    16.设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置maxclients0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息maxclients 12817.指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Reds新的vm机制，会把Key存放内存，Value会存放在swap区        maxmemory&lt;bytes&gt;    18.指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no         appendonly no    19.指定更新日志文件名，默认为appendonly.aof         appendfilename appendonly.aof    20.指定更新日志条件，共有3个可选值：        no：表示等操作系统进行数据缓存同步到磁盘（快）        always：表示每次更新操作后手动调用fsync（）将数据写到磁盘（慢，安全）        everysec：表示每秒同步一次（折衷，默认值）    21.指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）        vm-enabled no    22.虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享        vm-swap-file/tmp/redis.swap    23.将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的（Redis的索引数据就是keys），也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0        vm-max-memory 0    24.Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不确定，就使用默认值        vm-page-size 32    25.设置swap文件中的page数重，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。        vm-pages 134217728    26.设置访间swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4        vm-max-threads 4    27.设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启        glueoutputbuf yes    28.指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法        hash-max-zipmap-entries64        hash-max-zipmap-value 512    29.指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）        activerehashing yes    30.指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件        include/path/to/local.conf</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 命令类型 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis简介及使用场景</title>
      <link href="/posts/fc9ec3a7.html"/>
      <url>/posts/fc9ec3a7.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-简介及使用场景"><a href="#Redis-简介及使用场景" class="headerlink" title="Redis 简介及使用场景"></a>Redis 简介及使用场景</h2><blockquote><p><code>星星在你的头顶上闪耀着，与你交互诉说的话语，一句一句地，如同星点般翩然落至眼前</code></p></blockquote><h3 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h3><p>​    Redis 是完全开源免费的，遵守BSD协议，是一个高性能的<code>key-value</code>型数据库。</p><h3 id="二、window下的安装"><a href="#二、window下的安装" class="headerlink" title="二、window下的安装"></a>二、window下的安装</h3><blockquote><p>redis 64位下载地址：<a href="https://github.com/ServiceStack/redis-windows" target="_blank" rel="noopener">https://github.com/ServiceStack/redis-windows</a></p></blockquote><p>1.修改redis.windows.conf文件</p><pre><code>    maxmemory 1024*1024*1024</code></pre><p>2.启动redis</p><pre><code>    redis-server.exe redis.windows.conf</code></pre><p>3.将redis加入到windows的服务中</p><pre><code>    redis-server.exe --service-install redis.windows.conf --loglevel verbose</code></pre><p>4.常用的redis服务命令。</p><pre><code>卸载服务：redis-server --service-uninstall开启服务：redis-server --service-start停止服务：redis-server --service-stop重命名服务：redis-server --service-name name</code></pre><p>5.连接服务器</p><pre><code>redis-cli.exe</code></pre><h3 id="三、linix下的安装"><a href="#三、linix下的安装" class="headerlink" title="三、linix下的安装"></a>三、linix下的安装</h3><ol><li>安装<pre><code>$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz$ tar xzf redis-2.8.17.tar.gz$ cd redis-2.8.17$ make</code></pre></li><li>启动服务</li></ol><ul><li><p>默认启动</p><pre><code>$ cd src$ ./redis-server</code></pre></li><li><p>使用指定配置文件启动</p><pre><code>$ cd src$ ./redis-server ../redis.conf</code></pre></li></ul><h3 id="四、redis使用场景"><a href="#四、redis使用场景" class="headerlink" title="四、redis使用场景"></a>四、redis使用场景</h3><blockquote><p>参考<a href="https://blog.csdn.net/Bobdragery/article/details/99711762" target="_blank" rel="noopener"> redis使用场景及案例</a></p></blockquote><h4 id="一、缓存"><a href="#一、缓存" class="headerlink" title="一、缓存"></a>一、缓存</h4><p>项目场景：用户登录或注册时的验证码存储，用户名</p><pre><code>set Code:1:code 1232 EX 100 NXget Code:1:code     # 1232set User:1:name bob EX 100 NXget User:1:name         # bob</code></pre><p>缓存是 redis 出镜率最高的一种使用场景，仅仅使用 set/get 就可以实现，不过也有一些需要考虑的点<br>1、如何更好的设置缓存<br>2、如何保持缓存与上游数据的一致性<br>3、如何解决缓存雪崩，缓存击穿问题（这两个问题会单独写一篇）</p><h4 id="二：消息队列"><a href="#二：消息队列" class="headerlink" title="二：消息队列"></a>二：消息队列</h4><pre><code>lpush UserEmailQueue 1 2 3 4lpop UserEmailQueuerpop UserEmailQueue 1rpop UserEmailQueue 2</code></pre><p>可以把redis的队列看为分布式队列，作为消息队列时，生产者在一头塞入数据。消费者另一条取出数据:(lpush/rpop,rpush/lpop),不过也有一些不足，而这些不足有可能是致命的，不过对于一些丢几条消息也没关系的场景还是可以考虑的:<br>1、没有ack(消息确认机制)，有可能丢消息<br>2、需要做redis的持久化配置</p><h4 id="三：过滤器-dupefilter"><a href="#三：过滤器-dupefilter" class="headerlink" title="三：过滤器(dupefilter)"></a>三：过滤器(dupefilter)</h4><pre><code>sadd UrlSet http://1sadd UrlSet http://2sadd UrlSet http://2smembers UrlSet“http://1”“http://2”scrapy-redis作为分布式的爬虫框架，便是使用了 redis 的 Set 这个数据结构来对将要爬取的 url 进行去重处理。</code></pre><pre><code>def request_seen(self, request):    &quot;&quot;&quot;Returns True if request was already seen.   Parameters   -------request : scrapy.http.Request    Returns    ------- bool     &quot;&quot;&quot;     fp = self.request_fingerprint(request)     added = self.server.sadd(self.key, fp)     return added == 0不过当 url 过多时，会有内存占用过大的问题</code></pre><h4 id="四、分布式锁"><a href="#四、分布式锁" class="headerlink" title="四、分布式锁"></a>四、分布式锁</h4><p>分布式锁，这个是除了 KV 缓存之外最为常用的另一个特色功能。</p><pre><code>set Lock:User:10086 06be97fc-f258-4202-b60b-8d5412dd5605 EX 60 NX#释放锁，一段 LUA 脚本if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then      return redis.call(&quot;del&quot;,KEYS[1])else     return 0end</code></pre><p>这是一个最简单的单机版的分布式锁，有以下要点<br>1）EX 表示锁会过期释放<br>2）NX 保证原子性<br>解锁时对比资源对应产生的 UUID，避免误解锁<br>当你使用分布式锁是为了解决一些性能问题，如分布式定时任务防止执行多次 (做好幂等性)，而且鉴于单点 redis 挂掉的可能性很小，可以使用这种单机版的分布式锁。</p><p>举个例子说明：<br>比如一个很能干的资深工程师，开发效率很快，代码质量也很高，是团队里的明星。所以呢诸多产品经理都要来烦他，让他给自己做需求。如果同一时间来了一堆产品经理都找他，它的思路呢就会陷入混乱，再优秀的程序员，大脑的并发能力也好不到哪里去。所以呢他就在自己的办公室的门把上挂了一个请勿打扰的牌子，当一个产品经理来的时候先看看门把上有没有这个牌子，如果没有呢就可以进来找工程师谈需求，谈之前要把牌子挂起来，谈完了再把牌子摘了。这样其它产品经理也要来烦他的时候，如果看见这个牌子挂在那里，就可以选择睡觉等待或者是先去忙别的事。如是这位明星工程师从此获得了安宁。</p><p>一定要设置这个过期时间，因为遇到特殊情况 —— 比如地震（进程被 kill -9，或者机器宕机），产品经理可能会选择从窗户上跳下去，没机会摘牌，导致了死锁饥饿，让这位优秀的工程师成了一位大闲人，造成严重的资源浪费。同时还需要注意这个 owner_id，它代表锁是谁加的 —— 产品经理的工号。以免你的锁不小心被别人摘掉了。释放锁时要匹配这个 owner_id，匹配成功了才能释放锁。这个 owner_id 通常是一个随机数，存放在 ThreadLocal 变量里（栈变量）。官方其实并不推荐这种方式，因为它在集群模式下会产生锁丢失的问题 —— 在主从发生切换的时候。官方推荐的分布式锁叫 RedLock，作者认为这个算法较为安全，推荐我们使用。不过我们一直还使用上面最简单的分布式锁。为什么我们不去使用 RedLock 呢，因为它的运维成本会高一些，需要 3 台以上独立的 Redis 实例，用起来要繁琐一些。另外，Redis 集群发生主从切换的概率也并不高，即使发生了主从切换出现锁丢失的概率也很低，因为主从切换往往都有一个过程，这个过程的时间通常会超过锁的过期时间，也就不会发生锁的异常丢失。还有呢就是分布式锁遇到锁冲突的机会也不多，这正如一个公司里明星程序员也比较有限一样，总是遇到锁排队那说明结构上需要优化。</p><h4 id="五：定时任务"><a href="#五：定时任务" class="headerlink" title="五：定时任务"></a>五：定时任务</h4><p>分布式定时任务有多种实现方式，最常见的一种是 master-workers 模型。<br>master 负责管理时间，到点了就将任务消息仍到消息中间件里，然后worker们负责监听这些消息队列来消费消息。<br>著名的 Python 定时任务框架 Celery 就是这么干的。但是 Celery 有一个问题，那就是 master 是单点的，如果这个 master 挂了，整个定时任务系统就停止工作了。</p><p><a href="https://imgchr.com/i/3AVW1U" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/18/3AVW1U.png" alt="3AVW1U.png"></a></p><p>另一种实现方式是 multi-master 模型。这个模型什么意思呢，就类似于 Java 里面的 Quartz 框架，采用数据库锁来控制任务并发。会有多个进程，每个进程都会管理时间，时间到了就使用数据库锁来争抢任务执行权，抢到的进程就获得了任务执行的机会，然后就开始执行任务，这样就解决了 master 的单点问题。</p><p>这种模型有一个缺点，那就是会造成竞争浪费问题，不过通常大多数业务系统的定时任务并没有那么多，所以这种竞争浪费并不严重。还有一个问题它依赖于分布式机器时间的一致性，如果多个机器上时间不一致就会造成任务被多次执行，这可以通过增加数据库锁的时间来缓解。</p><p><a href="https://imgchr.com/i/3AVnfK" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/18/3AVnfK.png" alt="3AVnfK.png"></a></p><p>现在有了 Redis 分布式锁，那么我们就可以在 Redis 之上实现一个简单的定时任务框架。</p><pre><code>#注册定时任务hset tasks name trigger_rule#获取定时任务列表hgetall tasks#争抢任务set lock:$(name) true nx ex=5#任务列表变空#轮询版本号，有变化就重新加载任务列表，重新调度时间有变化的任务set tasks_version $new_versionget tasks_version</code></pre><h4 id="六、频率控制"><a href="#六、频率控制" class="headerlink" title="六、频率控制"></a>六、频率控制</h4><p>项目的社区功能里，不可避免的总是会遇到垃圾内容，一觉醒来你会发现首页突然会被某些恶意的帖子和广告刷屏了，如果不采取适当的机制来控制就会导致用户体验受到严重的影响。</p><p>控制广告垃圾贴的策略很多，高级一点的可以通过AI，最简单的方式是通过关键词扫描，还有比较常用的一种方式是频率控制，限制单个用户内容的生产速度，不通等级的用户会有不同的频率控制参数。</p><p>频率控制就可以使用redis来实现，我们将用户的行为理解为一个时间序列，我们要保证在一定的时间内限制单个用户的时间序列的长度，超过这个长度就禁止用户的行为，它可以是用redis的zset(有序集合)来实现</p><p><a href="https://imgchr.com/i/3AEsJK" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/18/3AEsJK.png" alt="3AEsJK.png"></a></p><p>图中绿色的部门就是我们要保留的一个时间段的时间序列信息，灰色的段会被砍掉。统计绿色段中时间序列记录的个数就知道是否超过了频率的阈值。</p><pre><code>下面的代码控制用户的ugc行为为每小时最对N次hist_key:&quot;ugc:${user_id}&quot;with redis.pipeline() as pipe:#记录当前的行为pipe.zadd(hist_key,ts,uuid)#保留1小时内的行为序列pipe.zremrangebyscore(hist_key, 0, now_ts -3600)# 获取这1小时的行为数量pipe.zcard(hist_key)# 设置过期时间，节约内存pipe.expire(hist_key, 3600)# 批量执行_ , _ , count, _ =pipe.exec()return count &gt; N</code></pre><h4 id="七、服务发现"><a href="#七、服务发现" class="headerlink" title="七、服务发现"></a>七、服务发现</h4><p>如果想要技术成熟度再高一些，有的企业会有服务发现的基础设施。通常我们都会选用zookeeper、etcd，consul等分布式配置数据库来作为服务列表的存储。<br>它们有非常及时的通知机制来通知服务消费者服务列表发生了变更。那我们该如何使用 Redis 来做服务发现呢？</p><p><a href="https://imgchr.com/i/3AEurj" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/18/3AEurj.png" alt="3AEurj.png"></a></p><p>这里我们要再次使用 zset 数据结构，我们使用 zset 来保存单个服务列表。多个服务列表就使用多个 zset 来存储。<br>zset 的 value 和 score 分别存储服务的地址和心跳的时间。服务提供者需要使用心跳来汇报自己的存活，每隔几秒调用一次 zadd。服务提供者停止服务时，使用 zrem 来移除自己。</p><pre><code>zadd service_key heartbeat_ts addrzrem service_key addr</code></pre><p>这样还不够，因为服务有可能是异常终止，根本没机会执行钩子，所以需要使用一个额外的线程来清理服务列表中的过期项</p><pre><code>zremrangebyscore service_key 0 now_ts -30 # 30s都没来心跳</code></pre><p>接下来还有一个重要的问题是如何通知消费者服务列表发生了变更，这里我们同样使用版本号轮询机制，当服务列表变更时，递增版本号。消费者通过轮询版本号的变化来重加载服务列表</p><pre><code>if zadd() &gt;0 || zrem() &gt;0 ||zremrangebuscore() &gt;0:        incr service_version_key</code></pre><p>但是还有一个问题，如果消费者依赖了很多的服务列表，那么它就需要轮询很多的版本号，这样的IO效率会比较低下。</p><p>这是我们可以再增加一个全局版本号，在任意的服务类表版本号发生变化时，递增全局版本号；</p><p>这样在正常情况下消费者只需要轮询全局版本号就可以了。当全局版本号发生变更时再挨个对依赖的服务类表的子版本号，然后加载有变更的服务列表</p><p><a href="https://imgchr.com/i/3AA48U" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/18/3AA48U.png" alt="3AA48U.png"></a></p><h4 id="八、位图"><a href="#八、位图" class="headerlink" title="八、位图"></a>八、位图</h4><p>项目里需要做一个球队成员的签到系统，当用户量比较少的时候，设计上比较简单，就是将用户的签到状态用redis的hash结构来存储，签到一次就再hash结构里记录一条，签到有三种状态：未签到，已签到和部签到，分别是0，1，2三个整数值。</p><pre><code>hset sign:$(user_id) 2019-08-11 1hset sign:$(user_id) 2019-08-12 0hset sign:$(user_id) 2019-08-14 2</code></pre><p>这个其实非常浪费用户空间，后来想做全部用户的签到，技术leader指出，这时候的再用hash就有问题了，他讲到当用户过千万的时候，内存可能会飚到 30G+，我们线上实例通常过了 20G 就开始报警，30G 已经属于严重超标了。</p><p>这时候我们就开始着手解决这个问题，去优化存储。我们选择使用位图来记录签到信息，一个签到状态需要两个位来记录，一个月的存储空间只需要 8 个字节。这样就可以使用一个很短的字符串来存储用户一个月的签到记录。</p><p><a href="https://imgchr.com/i/3AAeBR" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/18/3AAeBR.png" alt="3AAeBR.png"></a></p><p>但是位图也有一个缺点，它的底层是字符串，字符串是连续存储空间，位图会自动扩展，比如一个很大的位图 8m 个位，只有最后一个位是 1，其它位都是零，这也会占用1m 的存储空间，这样的浪费非常严重。</p><p>所以呢就有了咆哮位图这个数据结构，它对大位图进行了分段存储，全位零的段可以不用存。</p><p>另外还对每个段设计了稀疏存储结构，如果这个段上置 1 的位不多，可以只存储它们的偏移量整数。这样位图的存储空间就得到了非常显著的压缩。</p><h4 id="九、-模糊计数"><a href="#九、-模糊计数" class="headerlink" title="九、 模糊计数"></a>九、 模糊计数</h4><p>上面提到的签到系统，如果产品经理需要知道这个签到的日活月活怎么办呢？<br>通常我们会直接甩锅——请找数据部门。</p><p>但是数据部门的数据往往不是很实时，经常前一天的数据需要第二天才能跑出来，离线计算是通常是定时的一天一次。那如何实现一个实时的活跃计数？</p><p>最简单的方案就是在 Redis 里面维护一个 set 集合，来一个用户，就 sadd 一下，最终集合的大小就是我们需要的 UV 数字。</p><p>但是这个空间浪费严重怎么办？这时候就需要使用redis提供的HyperLogLog模糊计数功能，它是一种概率计数，有一定的误差，大约是0.81%。</p><p>但是空间占用很小，其底层是一个位图，它最多只会占用12k的存储空间，而且在计数值比较小的时候，位图使用稀疏存储，空间占用就更小了。</p><pre><code>#记录用户pfadd sign_uv_${day} user_id#获取记录数量p count sign_uv_${day}</code></pre><p>微信公众号文章的阅读数可以使用它，网页的 UV 统计它都可以完成。但是如果产品经理非常在乎数字的准确性，比如某个统计需求和金钱直接挂钩，那么你可以考虑一下前面提到的咆哮位图。</p><p>它使用起来会复杂一些，需要提前将用户 ID 进行整数序列化。Redis 没有原生提供咆哮位图的功能，但是有一个开源的 Redis Module 可以拿来即用。</p><h4 id="十、布隆过滤器"><a href="#十、布隆过滤器" class="headerlink" title="十、布隆过滤器"></a>十、布隆过滤器</h4><p>如果系统即将会有大量的新用户涌入时，布隆过滤器就会非常有价值，可以显著降低缓存的穿透率，降低数据库的压力<br>这个新用户的涌入不一定是业务系统的大规模铺开，也可能是因为来自外部的缓存穿透攻击；</p><pre><code>def get_user_state(user_id):        state = cache.get(user_id)        if not state:            state = db.get(user_id) or{}            cache.set(user_id,state)        return statedef save_user_state(user_id,state):        cache.set(user_id,state)        db.set_async(user_id,state)</code></pre><p>比如就上面这个业务系统的用户状态查询接口代码，现在一个新用户过来，会先去缓存里查询有没有这个用户的状态数据<br>因为是新用户，所以肯定缓存里没有，然后它就要去数据库里查，结过数据库也没有，如果这样的新用户大批量瞬间涌入，那么可以遇见数据库的压力会比较大，会存在大量的空查询；</p><p>我们非常希望redis里面有这样一个set，它存放了所有的用户id，这样通过查询这个set集合就知道是不是新用户来了<br>当用户量非常庞大的时候，维护这样的一个集合需要的存储空间是很大的；</p><p>这时候就可以使用布隆过滤器，它相当于一个set，但是又不同于set，它需要的存储空间要小的多；</p><p>比如存储一个用户id需要64个字节，而布隆过滤器存储一个用户ID只需要1个字节多点，其实它存的不是用户id，而是用户id的指纹，所以会存在一定的小概率误判，它是一个具备模糊过滤能力的容器；</p><p>当它说用户 id 不在容器中时，那么就肯定不在。当它说用户 id 在容器里时，99% 的概率下它是正确的，还有 1% 的概率它产生了误判。</p><p><a href="https://imgchr.com/i/3AkEwt" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/18/3AkEwt.png" alt="3AkEwt.png"></a></p><p>不过在这个案例中，这个误判并不会产生问题，误判的代价只是缓存穿透而已。<br>相当于有 1% 的新用户没有得到布隆过滤器的保护直接穿透到数据库查询，而剩下的 99% 的新用户都可以被布隆过滤器有效的挡住，避免了缓存穿透</p><p><a href="https://imgchr.com/i/3AFurR" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/18/3AFurR.png" alt="3AFurR.png"></a></p><p>布隆过滤器的原理有一个很好的比喻，那就是在冬天一片白雪覆盖的地面上，如果你从上面走过，就会留下你的脚印。如果地面上有你的脚印，那么就可以大概率断定你来过这个地方，但是也不一定，也许别人的鞋正好和你穿的一模一样。可是如果地面上没有你的脚印，那么就可以 100% 断定你没来过这个地方。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 简介 </tag>
            
            <tag> 使用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA反射的整理和理解</title>
      <link href="/posts/33aa4888.html"/>
      <url>/posts/33aa4888.html</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h2><blockquote><p> <code>星星在你的头顶上闪耀着，与你交互诉说的话语，一句一句地，如同星点般翩然落至眼前</code></p></blockquote><hr><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><blockquote><p>  JAVA反射机制是在运行状态中.<br>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性.</p></blockquote><blockquote><p>我们创建的每一个类也都是对象，即类本身是java.lang.Class类的实例对象。这个实例对象称之为类对象，也就是Class对象,或者类类型。</p></blockquote><h3 id="二、方法："><a href="#二、方法：" class="headerlink" title="二、方法："></a>二、方法：</h3><h4 id="1-如何获取-Class文件对象"><a href="#1-如何获取-Class文件对象" class="headerlink" title="1.如何获取.Class文件对象"></a>1.如何获取.Class文件对象</h4><pre><code>a.  通过Object类 getClass()方法获取 Class对象b. 通过类名.class 方式 获取 Class对象c.  通过反射的方式, Class.forName(String classname) 获取Class对象public static Class&lt;?&gt; forName(String className)throws ClassNotFoundException返回与带有给定字符串名的类或接口相关联的 Class 对象</code></pre><h4 id="2-通过反射，获取类中的构造方法，并完成对象的创建"><a href="#2-通过反射，获取类中的构造方法，并完成对象的创建" class="headerlink" title="2.通过反射，获取类中的构造方法，并完成对象的创建"></a>2.通过反射，获取类中的构造方法，并完成对象的创建</h4><ul><li><p>获取指定的构造方法</p><p>  public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</p></li><li><p>获取指定的public修饰的构造方法</p><p>  public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</p></li><li><p>获取指定的构造方法，包含私有的</p><p>  public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</p></li><li><p>获取所有的构造方法</p><p>  public Constructor<?>[] getConstructors() 获取所有的public 修饰的构造方法  public Constructor<?>[] getDeclaredConstructors() 获取所有的构造方法，包含私有的</p></li></ul><h4 id="3-通过反射，-获取类中的构造方法，并完成对象的创建"><a href="#3-通过反射，-获取类中的构造方法，并完成对象的创建" class="headerlink" title="3.通过反射， 获取类中的构造方法，并完成对象的创建"></a>3.通过反射， 获取类中的构造方法，并完成对象的创建</h4><pre><code>步骤：a.获取字节码文件对象b.通过字节码文件对象 ，获取到指定的构造方法    getConstructor(参数);c.通过构造方法，创建对象    public T newInstance(Object... initargs)</code></pre><h4 id="4-私有构造方法，创建对象"><a href="#4-私有构造方法，创建对象" class="headerlink" title="4.私有构造方法，创建对象"></a>4.私有构造方法，创建对象</h4><pre><code>a.获取字节码文件对象b.通过字节码文件对象 ，获取到指定的构造方法    getDeclaredConstructor (参数);c.暴力访问     con.setAccessible(true);d.通过构造方法，创建对象     public T newInstance(Object... initargs)</code></pre><h4 id="5-通过反射，获取Class文件中的方法"><a href="#5-通过反射，获取Class文件中的方法" class="headerlink" title="5.通过反射，获取Class文件中的方法"></a>5.通过反射，获取Class文件中的方法</h4><ul><li><p>获取指定的方法</p><p>  public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</p></li><li><p>获取指定的public方法</p><p>  public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</p></li><li><p>获取指定的任意方法，包含私有的</p><p>  获取所有的方法:<br>  public Method[] getMethods()</p><p>  获取本类与父类中所有public 修饰的方法:<br>  public Method[] getDeclaredMethods()获取本类中包含私有的所有的方法</p></li></ul><blockquote><p>// 数组表示：new Class[]{String.class, String.class}</p></blockquote><h4 id="6-通过反射，调用方法"><a href="#6-通过反射，调用方法" class="headerlink" title="6.通过反射，调用方法"></a>6.通过反射，调用方法</h4><pre><code>步骤：a.获取Class对象b.构造方法，创建对象c.取指定的public方法d.行方法public Object invoke(Object obj, Object... args)</code></pre><h4 id="7-私有方法的调用："><a href="#7-私有方法的调用：" class="headerlink" title="7.私有方法的调用："></a>7.私有方法的调用：</h4><pre><code>a，获取Class对象b,获取构造方法，创建对象c,获取指定的private方法d,开启暴力访问m5.setAccessible(true);e,执行方法public Object invoke(Object obj, Object... args)</code></pre><h4 id="8-通过反射，获取成员变量"><a href="#8-通过反射，获取成员变量" class="headerlink" title="8.通过反射，获取成员变量"></a>8.通过反射，获取成员变量</h4><ul><li><p>获取指定的成员变量</p><p>   public Field getField(String name) </p></li><li><p>获取public修饰的成员变量</p><p>  public Field getDeclaredField(String name)</p></li><li><p>获取任意的成员变量，包含私有</p><p>  public Field[] getFields() </p></li><li><p>获取所有public修饰的成员变量</p><p>  public Field[] getDeclaredFields()</p></li></ul><h4 id="9-通过反射，获取成员-变量，并赋值使用"><a href="#9-通过反射，获取成员-变量，并赋值使用" class="headerlink" title="9.通过反射，获取成员 变量，并赋值使用"></a>9.通过反射，获取成员 变量，并赋值使用</h4><pre><code>步骤：a. 获取字节码文件对象b. 获取构造方法，创建对象c. 获取指定的成员变量d. 对成员变量赋值获取值操作public void set(Object obj, Object value) // 赋值public Object get(Object obj) // 获取值</code></pre><h4 id="10-私有成员变量的使用"><a href="#10-私有成员变量的使用" class="headerlink" title="10.私有成员变量的使用"></a>10.私有成员变量的使用</h4><pre><code>步骤：a. 获取字节码文件对象b. 获取构造方法，创建对象c. 获取指定的成员变量d. 开启暴力访问e. 对成员变量赋值获取值操作public void set(Object obj, Object value) //赋值public Object get(Object obj) //获取值</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速博客网站的建议细节</title>
      <link href="/posts/489a4cf4.html"/>
      <url>/posts/489a4cf4.html</url>
      
        <content type="html"><![CDATA[<h2 id="优化加速博客网站的建议细节"><a href="#优化加速博客网站的建议细节" class="headerlink" title="优化加速博客网站的建议细节"></a>优化加速博客网站的建议细节</h2><blockquote><p><code>莫扎特曾经说过大胆地踏上旅途吧，我不知道路途的前方究竟有什么，但是，我们还是迈出了步伐，我们仍在旅途之中</code></p></blockquote><hr><p>目前本人对前端 SEO 等也正处于探索和学习的阶段上，希望有任何问题和建议请留言哦~</p><h3 id="1-为什么要优化呢"><a href="#1-为什么要优化呢" class="headerlink" title="1. 为什么要优化呢?"></a>1. 为什么要优化呢?</h3><blockquote><p>​    当你打开一个网站时迟迟未能看见显示的页面的时候是不是很暴躁好没耐心呢，所以网站的优化对于开发者来说是不可少的工作呢。</p></blockquote><blockquote><p> 而可能大多数人和我一样，对于可以不用购买服务器，直接使用Hexo生成静态页面，使用<code>GitHub Pages</code>作为服务器，这样就可以搭建出自己博客了。</p><p>如何使用Hexo和GitHub搭建博客请参考我另外篇文章 &gt; <a href="https://blog.onfree.cn/qian-duan/c1595c80.html">基于Hexo和 hexo-theme-matery的个性化定制开发</a></p></blockquote><blockquote><p> 然而有个问题，<code>GitHub</code>的访问速度太慢了，对于我来说太暴躁了！所以就想寻找出更多的优化方法来解决这问题。</p></blockquote><h3 id="2-如何优化呢"><a href="#2-如何优化呢" class="headerlink" title="2.如何优化呢?"></a>2.如何优化呢?</h3><h4 id="1-更换搭建环境"><a href="#1-更换搭建环境" class="headerlink" title="1.更换搭建环境"></a>1.更换搭建环境</h4><p>不使用<code>GitHub</code>来搭建博客,而选择使用<code>Gitee</code>或者<code>coding</code>来搭建，当然有些人会觉得还是<code>GitHub</code>的习惯点呢；</p><h4 id="2-所有的类库使用CDN加速"><a href="#2-所有的类库使用CDN加速" class="headerlink" title="2. 所有的类库使用CDN加速"></a>2. 所有的类库使用CDN加速</h4><p>目前稳定且好的推荐如下：</p><ul><li><a href="http://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr </a></li><li><a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">bootcdn</a></li><li><a href="http://www.staticfile.org" target="_blank" rel="noopener">staticfile</a></li><li><a href="https://cdn.baomitu.com" target="_blank" rel="noopener">baomitu</a></li></ul><blockquote><p>使用方法就是像本地一样更换成线上的网址就行了</p><p>如：<code>&lt;script src=&quot;https://cdn.bootcss.com/aos/3.0.0-beta.6/aos.js&quot;&gt;&lt;/script&gt;</code></p></blockquote><h4 id="3-自定义Js、Css等文件加速"><a href="#3-自定义Js、Css等文件加速" class="headerlink" title="3.  自定义Js、Css等文件加速"></a>3.  自定义Js、Css等文件加速</h4><p>​    使用GitHub+<a href="http://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr </a>的方式加速，jsdelivr 可以直接通过引用 Github 的资源，所有用来做CDN加速也不错;</p><p>使用方法：直接引用就行，如：<code>https://cdn.jsdelivr.net/gh/用户名/仓库名/文件</code>。</p><p>如我的用户名为：athink8 ; 仓库名：myGithub.；想引用的文件：/libs/others/clicklove.js</p><p>那引用链接为：</p><p><code>https://cdn.jsdelivr.net/gh</code>/</p><p>​    + <code>athink8/myGithub/libs/others/clicklove.js</code></p><blockquote><p>防坑指南：正常来说你需要GitHub打包才可以标识访问,虽然偷工减料，但是有时候会出现资源未更新的情况，</p><p>​    正确的做法是 加上<code>@latest</code> 这样就可以依然不打包使用最新提交的资源了。</p><p>​    如:<code>https://cdn.jsdelivr.net/gh/athink8/</code></p><p>​    + <code>myGithub@latest/libs/others/clicklove.js</code></p></blockquote><h4 id="4-图片资源处理"><a href="#4-图片资源处理" class="headerlink" title="4. 图片资源处理"></a>4. 图片资源处理</h4><p>​    图片一般都挺大的，为了加快访问速度当然需要做些变动才行呢。</p><p>​    尽量不使用本地图片，而改成使用线上<code>图床</code>。</p><p>​    什么是图床呢?图床一般是指储存图片的服务器。</p><p>​    图床推荐：</p><ul><li><a href="http://photo.weibo.com" target="_blank" rel="noopener">微博</a> : 免费、有损质量</li><li><a href="https://portal.qiniu.com" target="_blank" rel="noopener">七牛云</a>:10G免费空间，每月10G国内和10G国外流量，速度快</li><li><a href="https://www.upyun.com" target="_blank" rel="noopener">又拍云</a>: 注册认证后有10G免费空间，每月15G的HTTP和HTTPS流量,需加logo</li><li><a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a>：免费</li><li><a href="https://imgchr.com" target="_blank" rel="noopener">路过图床</a>：免费</li><li>阿里oss：收费、稳定</li><li>腾讯cos：新用户六个月的免费存储容量、免费请求和免费流量</li><li>GitHub+jsdelivr 搭建</li></ul><h4 id="5-代码压缩"><a href="#5-代码压缩" class="headerlink" title="5. 代码压缩"></a>5. 代码压缩</h4><p>精简代码可以有效的提高优化呢，如所说的类库也尽量使用带有min的版本。</p><p>手动压缩代码可以使用一些工具，如 <a href="http://tool.chinaz.com/js.aspx" target="_blank" rel="noopener">站长工具</a>、<a href="http://www.atoolbox.net/Tool.php?Id=664" target="_blank" rel="noopener">压缩工具箱</a>。</p><p>自动压缩的话，如果是使用hexo搭建博客的话可以使用gulp压缩代码，安装如下：</p><ol><li>进入站点根目录下执行下面的命令：</li></ol><pre><code># 全局安装gulp模块npm install gulp -g# 安装各种功能模块npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save# 安装额外功能模块npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save</code></pre><ol start="2"><li>在站点根目录新建文件 <code>gulpfile.js</code>，并复制以下内容</li></ol><pre><code>ar gulp = require(&quot;gulp&quot;);var debug = require(&quot;gulp-debug&quot;);var cleancss = require(&quot;gulp-clean-css&quot;); //css压缩组件var uglify = require(&quot;gulp-uglify&quot;); //js压缩组件var htmlmin = require(&quot;gulp-htmlmin&quot;); //html压缩组件var htmlclean = require(&quot;gulp-htmlclean&quot;); //html清理组件var imagemin = require(&quot;gulp-imagemin&quot;); //图片压缩组件var changed = require(&quot;gulp-changed&quot;); //文件更改校验组件var gulpif = require(&quot;gulp-if&quot;); //任务 帮助调用组件var plumber = require(&quot;gulp-plumber&quot;); //容错组件（发生错误不跳出任务，并报出错误内容）var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)var isDebug = true; //是否调试显示 编译通过的文件var gulpBabel = require(&quot;gulp-babel&quot;);var es2015Preset = require(&quot;babel-preset-es2015&quot;);var del = require(&quot;del&quot;);var Hexo = require(&quot;hexo&quot;);var hexo = new Hexo(process.cwd(), {}); // 初始化一个hexo对象// 清除public文件夹gulp.task(&quot;clean&quot;, function () {    return del([&quot;public/**/*&quot;]);});// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return// 创建静态页面 （等同 hexo generate）gulp.task(&quot;generate&quot;, function () {    return hexo.init().then(function () {        return hexo            .call(&quot;generate&quot;, {                watch: false            })            .then(function () {                return hexo.exit();            })            .catch(function (err) {                return hexo.exit(err);            });    });});// 启动Hexo服务器gulp.task(&quot;server&quot;, function () {    return hexo        .init()        .then(function () {            return hexo.call(&quot;server&quot;, {});        })        .catch(function (err) {            console.log(err);        });});// 部署到服务器gulp.task(&quot;deploy&quot;, function () {    return hexo.init().then(function () {        return hexo            .call(&quot;deploy&quot;, {                watch: false            })            .then(function () {                return hexo.exit();            })            .catch(function (err) {                return hexo.exit(err);            });    });});// 压缩public目录下的js文件gulp.task(&quot;compressJs&quot;, function () {    return gulp        .src([&quot;./public/**/*.js&quot;, &quot;!./public/libs/**&quot;]) //排除的js        .pipe(gulpif(!isScriptAll, changed(&quot;./public&quot;)))        .pipe(gulpif(isDebug, debug({ title: &quot;Compress JS:&quot; })))        .pipe(plumber())        .pipe(            gulpBabel({                presets: [es2015Preset] // es5检查机制            })        )        .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩        .pipe(gulp.dest(&quot;./public&quot;)); //输出到目标目录});// 压缩public目录下的css文件gulp.task(&quot;compressCss&quot;, function () {    var option = {        rebase: false,        //advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]        compatibility: &quot;ie7&quot; //保留ie7及以下兼容写法 类型：String 默认：&#39;&#39;or&#39;*&#39; [启用兼容模式； &#39;ie7&#39;：IE7兼容模式，&#39;ie8&#39;：IE8兼容模式，&#39;*&#39;：IE9+兼容模式]        //keepBreaks: true, //类型：Boolean 默认：false [是否保留换行]        //keepSpecialComments: &#39;*&#39; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀    };    return gulp        .src([&quot;./public/**/*.css&quot;, &quot;!./public/**/*.min.css&quot;]) //排除的css        .pipe(gulpif(!isScriptAll, changed(&quot;./public&quot;)))        .pipe(gulpif(isDebug, debug({ title: &quot;Compress CSS:&quot; })))        .pipe(plumber())        .pipe(cleancss(option))        .pipe(gulp.dest(&quot;./public&quot;));});// 压缩public目录下的html文件gulp.task(&quot;compressHtml&quot;, function () {    var cleanOptions = {        protect: /&lt;\!--%fooTemplate\b.*?%--&gt;/g, //忽略处理        unprotect: /&lt;script [^&gt;]*\btype=&quot;text\/x-handlebars-template&quot;[\s\S]+?&lt;\/script&gt;/gi //特殊处理    };    var minOption = {        collapseWhitespace: true, //压缩HTML        collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;        removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;        removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=&quot;text/javascript&quot;        removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;        removeComments: true, //清除HTML注释        minifyJS: true, //压缩页面JS        minifyCSS: true, //压缩页面CSS        minifyURLs: true //替换页面URL    };    return gulp        .src(&quot;./public/**/*.html&quot;)        .pipe(gulpif(isDebug, debug({ title: &quot;Compress HTML:&quot; })))        .pipe(plumber())        .pipe(htmlclean(cleanOptions))        .pipe(htmlmin(minOption))        .pipe(gulp.dest(&quot;./public&quot;));});// 压缩 public/medias 目录内图片gulp.task(&quot;compressImage&quot;, function () {    var option = {        optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级）        progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片        interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染        multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化    };    return gulp        .src(&quot;./public/medias/**/*.*&quot;)        .pipe(gulpif(!isScriptAll, changed(&quot;./public/medias&quot;)))        .pipe(gulpif(isDebug, debug({ title: &quot;Compress Images:&quot; })))        .pipe(plumber())        .pipe(imagemin(option))        .pipe(gulp.dest(&quot;./public&quot;));});// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器gulp.task(    &quot;build&quot;,    gulp.series(        &quot;clean&quot;,        &quot;generate&quot;,        &quot;compressHtml&quot;,        &quot;compressCss&quot;,        &quot;compressJs&quot;,        &quot;compressImage&quot;,        gulp.parallel(&quot;deploy&quot;)    ));// 默认任务gulp.task(    &quot;default&quot;,    gulp.series(        &quot;clean&quot;,        &quot;generate&quot;,        gulp.parallel(&quot;compressHtml&quot;, &quot;compressCss&quot;, &quot;compressJs&quot;,&quot;compressImage&quot;)    ));//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数</code></pre><ol start="3"><li>执行方式有两种：</li></ol><ul><li>执行 <code>gulp</code>或者 <code>gulp default</code> ，这个命令相当于 <code>hexo cl&amp;&amp;hexo g</code> 并且再把代码压缩。</li><li>执行 <code>gulp build</code> ，这个命令与第1种相比是在最后又加了个 <code>hexo d</code> ，等于说生成、压缩文件后并自动部署。</li></ul><blockquote><p>值得注意的是：这个加入了图片压缩，如果不想用图片压缩可以把第154行的 <code>&quot;compressImage&quot;,</code> 和第165行的 <code>,&quot;compressImage&quot;</code> 去掉即可</p></blockquote><h4 id="6-图片懒加载"><a href="#6-图片懒加载" class="headerlink" title="6.  图片懒加载"></a>6.  图片懒加载</h4><ol><li><p>hexo安装懒加载插件：<a href="https://github.com/Troy-Yang/hexo-lazyload-image" target="_blank" rel="noopener">hexo-lazyload-image</a></p></li><li><p>在站点根目录执行下面的命令：</p><pre><code>npm install hexo-lazyload-image --save</code></pre></li><li><p>在站点配置文件下添加下面的代码：</p></li></ol><pre><code>lazyload:  enable: true  #开启图片懒加载  onlypost: false  # 是否只对文章的图片做懒加载  loadingImg: # eg ./images/loading.gif #图片未加载的图片</code></pre><ol start="4"><li>最后执行<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>就可以看到效果了。</li></ol><h4 id="7-全站托管使用CDN"><a href="#7-全站托管使用CDN" class="headerlink" title="7.  全站托管使用CDN"></a>7.  全站托管使用CDN</h4><blockquote><p>这才是重点嘛</p></blockquote><p>国内付费的CDN服务商有阿里云、腾讯云等应该都不错的样子。</p><p>然而还是看看有没有免费的吧。(穷)</p><p>本人觉得还不错且稳定的推荐:<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare</a></p><p>虽然CloudFlare CDN节点基本上在国外,国内的少且经常不通，但是将就着用吧。</p><blockquote><p>推荐使用第三方 CloudFlare 面板来接入，因为中文可以看的懂，也支持允许 CNAME 方式接入 CloudFlare</p><p> CloudFlare 面板提供商：</p><ul><li><a href="http://cdn.bnxb.com/" target="_blank" rel="noopener">笨牛网-Cloudflare免费CDN管理平台</a> </li><li><a href="https://cf.tlo.xyz/" target="_blank" rel="noopener">TLOXYGEN</a> </li><li><a href="https://cdn.wzfou.com/" target="_blank" rel="noopener">挖站否-CF 管理平台</a></li></ul></blockquote><hr><blockquote><p><code>目前已知优化如上所述，如我发现更多优化技巧将会持续更新的~</code></p></blockquote><blockquote><p><code>欢迎各位朋友还有啥建议的欢迎留言哈~</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo和 hexo-theme-matery的个性化定制开发</title>
      <link href="/posts/c1595c80.html"/>
      <url>/posts/c1595c80.html</url>
      
        <content type="html"><![CDATA[<h2 id="基于Hexo和-hexo-theme-matery的个性化定制开发"><a href="#基于Hexo和-hexo-theme-matery的个性化定制开发" class="headerlink" title="基于Hexo和 hexo-theme-matery的个性化定制开发"></a>基于Hexo和 hexo-theme-matery的个性化定制开发</h2><blockquote><p><code>就算悲伤难抑，遍体鳞伤地处于谷底，也不能停止演奏！</code></p></blockquote><hr><p><strong>本博客基于hexo开发，使用的主题是 @blinkfox 的主题 <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">  hexo-theme-matery</a></strong> </p><blockquote><p>hexo 是基于node.js制作的一个博客工具，支持多种主题更换，主要是基于YAML来配置所需信息即可，通过markdown编写文章，hexo 能够快速构建出静态的html页面，而静态页面可以放在GitHub、Gitee等代码托管上，而无需自己购买服务器。</p></blockquote><blockquote><p>同时<strong>hexo</strong>支持更换不同好看个性的主题,比如 <strong><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next</a></strong>  、<strong><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a></strong>  等。</p></blockquote><h3 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一. 环境搭建"></a>一. 环境搭建</h3><ul><li><p>本地安装Git（版本控制工具）</p></li><li><p>本地安装NodeJs（服务端的 JavaScript）</p></li><li><p>GitHub创建和Github Pages创建</p></li></ul><h4 id="1-本地安装Git"><a href="#1-本地安装Git" class="headerlink" title="1. 本地安装Git"></a>1. 本地安装Git</h4><p>1.1 Git下载地址（本文默认基于Window环境下开发）<a href="https://git-scm.com" target="_blank" rel="noopener">git官网</a></p><blockquote><p>因为官网下载会比较慢，推荐使用淘宝镜像快速下载  <a href="https://npm.taobao.org/mirrors/git-for-windows/v2.25.0.windows.1/Git-2.25.0-32-bit.exe" target="_blank" rel="noopener">点击下载</a></p></blockquote><p>1.2 下载完后点击安装文件并一直下一步运行成功即可，右键会看见 <code>Git Bash</code>，</p><p>打开输入  <code>git --version</code>出现版本数即为成功。</p><p>1.3 有关Git用法请参考 <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">文档</a></p><blockquote><p>常用命令：</p></blockquote><pre class=" language-console"><code class="language-console">#使用前配置全局信息git config --global user.name '你的名字'git config --global user.email '你的邮箱'#查看是否已配置成功git config --list --global#在你需要使用Git的文件夹下运行git init                        #初始化git add .                        #添加变更文件到暂存区git status                        #查看变更信息git commit -m '你需要写的信息'        #提交到工作区git remote add origin https://github.com/用户名/仓库名.git    #添加Github远程连接git push origin                 #上传到GitHubgit push origin -f                #强制上传到GitHub</code></pre><h4 id="2-本地安装NodeJs"><a href="#2-本地安装NodeJs" class="headerlink" title="2. 本地安装NodeJs"></a>2. 本地安装NodeJs</h4><p>2.1 NodeJs 下载地址： <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">点击下载</a></p><p>2.2 下载完后也是一直下一步就好 ，输入 <strong>node -v</strong> 查询版本就可。</p><blockquote><p>因为官方镜像源比较慢，推荐如下修改为国内的淘宝镜像源</p></blockquote><pre class=" language-console"><code class="language-console"># 临时修改镜像源npm --registry=https://registry.npm.taobao.org# 永久设置为淘宝镜像源npm config set registry https://registry.npm.taobao.org# 查看npm的配置npm config list</code></pre><blockquote><p>修改默认内置路径，在安装路径上创建 node_global<code>和</code>node_cache, 如以下：</p></blockquote><pre><code>D:\Program Files\nodejs\node_globalD:\Program Files\nodejs\node_cache</code></pre><blockquote><p>执行命令：</p></blockquote><pre><code>npm config set prefix&quot;D:\Program Files\nodejs\node_global&quot;npm config set cache &quot;D:\Program Files\nodejs\node_cache&quot;</code></pre><h4 id="3-GitHub创建和Github-Pages创建"><a href="#3-GitHub创建和Github-Pages创建" class="headerlink" title="3. GitHub创建和Github Pages创建"></a>3. GitHub创建和Github Pages创建</h4><p>3.1 打开Github<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fgithub.com%2F" target="_blank" rel="noopener">官网首页</a>，注册登录并创建仓库，并创建文件 index.html 即可.</p><p>3.2 在Setting 中往下拉找到 GitHub Pages 配置即可访问连接。</p><h3 id="二-博客开发"><a href="#二-博客开发" class="headerlink" title="二 . 博客开发"></a>二 . 博客开发</h3><h4 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1. 安装Hexo"></a>1. 安装Hexo</h4><blockquote><p>在你想要保存博客文件的路径上创建文件夹，如E:\my\hexo_blog，按住 win+r 弹出框里输入 cmd 进入控制台</p></blockquote><pre><code>#进入博客文件夹的上一级目录 cd E:\my# 安装hexonpm install -g hexo-cli#初始化文件夹hexo init hexo_blog #进入博客文件夹cd E:\my\hexo_blog# 安装博客需要的依赖文件npm install  </code></pre><blockquote><p>hexo命令  <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官网文档</a></p></blockquote><pre><code>hexo cl    #清理hexo g    #生成hexo s    #本地服务 hexo d    #发布</code></pre><blockquote><p>本地测试 <a href="http://locakhost:4000" target="_blank" rel="noopener">http://locakhost:4000</a> 或者127.0.0.1:4000</p></blockquote><h4 id="2-hexo配置"><a href="#2-hexo配置" class="headerlink" title="2.hexo配置"></a>2.hexo配置</h4><blockquote><p>hexo 目录结构</p></blockquote><pre><code>_config.yml          配置文件_public            生成的静态文件，这个目录最终会发布到服务器  _scaffolds         通用模板  _source         保存编写的markdown文件drafts            草稿文件themes             博客主题node_modules     类库</code></pre><blockquote><p><code>_config.yml</code>配置</p></blockquote><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#网站</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 你的博客名<span class="token key atrule">subtitle</span><span class="token punctuation">:</span> 博客副标题<span class="token key atrule">description</span><span class="token punctuation">:</span> 博客描述(主要用于SEO)<span class="token key atrule">keywords</span><span class="token punctuation">:</span> 博客关键词(主要用于SEO)<span class="token key atrule">author</span><span class="token punctuation">:</span> 作者(用于主题显示文章的作者)<span class="token key atrule">language</span><span class="token punctuation">:</span> 博客语言  <span class="token key atrule">timezone</span><span class="token punctuation">:</span> 时区<span class="token comment" spellcheck="true">#网址</span>url    <span class="token punctuation">:</span>网址    root <span class="token punctuation">:</span>网站根目录    <span class="token key atrule">permalink</span><span class="token punctuation">:</span> 文章的永久链接格式 <span class="token punctuation">:</span>year/<span class="token punctuation">:</span>month/<span class="token punctuation">:</span>day/<span class="token punctuation">:</span>title/<span class="token key atrule">permalink_defaults</span><span class="token punctuation">:</span>    永久链接中各部分的默认值    <span class="token key atrule">pretty_urls</span><span class="token punctuation">:</span> 改写 permalink 的值来美化 URL    <span class="token key atrule">pretty_urls.trailing_index</span><span class="token punctuation">:</span> 是否在永久链接中保留尾部的 index.html，设置为 false时去除<span class="token key atrule">pretty_urls.trailing_html</span><span class="token punctuation">:</span> 是否在永久链接中保留尾部的 .html<span class="token punctuation">,</span> 设置为 false 时去除<span class="token comment" spellcheck="true">#目录(基本不需改)</span>source_dir        资源文件夹，这个文件夹用来存放内容public_dir        公共文件夹，这个文件夹用于存放chang生成的站点文件tag_dir            标签文件夹archive_dir        归档文件夹category_dir    分类文件夹code_dir        Include code 文件夹，source_dir 下的子目录i18n_dir        国际化（i18n）文件夹skip_render        跳过指定文件的渲染。(常用于跳过GitHub的README.md渲染)<span class="token comment" spellcheck="true">#分页</span>per_page        每页显示的文章量 (0 关闭分页功能<span class="token punctuation">,</span>默认10)pagination_dir    分页目录<span class="token comment" spellcheck="true">#主题</span>theme：当前主题名称<span class="token comment" spellcheck="true">#发布</span><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repo</span><span class="token punctuation">:</span> 仓库  <span class="token key atrule">branch</span><span class="token punctuation">:</span> 分支</code></pre><h4 id="3-使用主题和配置"><a href="#3-使用主题和配置" class="headerlink" title="3. 使用主题和配置"></a>3. 使用主题和配置</h4><blockquote><p>参考博客 <a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">Hexo博客主题之hexo-theme-matery的介绍</a></p></blockquote><h5 id="3-1-下载主题："><a href="#3-1-下载主题：" class="headerlink" title="3.1 下载主题："></a>3.1 下载主题：</h5><h5 id="hexo-theme-matery-放在站点目录文件夹下-themes-文件夹中即可。"><a href="#hexo-theme-matery-放在站点目录文件夹下-themes-文件夹中即可。" class="headerlink" title=" hexo-theme-matery  放在站点目录文件夹下 themes 文件夹中即可。"></a><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener"> hexo-theme-matery</a>  放在站点目录文件夹下 <code>themes</code> 文件夹中即可。</h5><h5 id="3-2-在站点配置文件-config-yml修改theme-主题名"><a href="#3-2-在站点配置文件-config-yml修改theme-主题名" class="headerlink" title="3.2 在站点配置文件_config.yml修改theme: 主题名"></a>3.2 在站点配置文件<code>_config.yml</code>修改<code>theme: 主题名</code></h5><blockquote><p>防坑指南：设置的主题名和下载的主题名要完全一致</p></blockquote><h5 id="3-3-新建分类-categories-页"><a href="#3-3-新建分类-categories-页" class="headerlink" title="3.3 新建分类 categories 页"></a>3.3 新建分类 categories 页</h5><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span></code></pre><p>编辑文件 <code>/source/categories/index.md</code>，内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-02-10</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span></code></pre><h5 id="3-4-新建标签-tags-页"><a href="#3-4-新建标签-tags-页" class="headerlink" title="3.4 新建标签 tags 页"></a>3.4 新建标签 tags 页</h5><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span></code></pre><p>编辑文件 <code>/source/tags/index.md</code>，内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span></code></pre><h5 id="3-5-新建关于我-about-页"><a href="#3-5-新建关于我-about-页" class="headerlink" title="3.5 新建关于我 about 页"></a>3.5 新建关于我 about 页</h5><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span></code></pre><p>编辑文件 <code>/source/about/index.md</code>，内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span></code></pre><h5 id="3-6-新建友情连接-friends-页（可选的）"><a href="#3-6-新建友情连接-friends-页（可选的）" class="headerlink" title="3.6 新建友情连接 friends 页（可选的）"></a>3.6 新建友情连接 friends 页（可选的）</h5><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span></code></pre><p>编辑文件 <code>/source/friends/index.md</code>，内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://s2.ax1x.com/2020/02/13/1q6iAs.th.png"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Athink_"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"加油 你可以的"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blog.onfree.cn/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h5 id="3-7-代码高亮"><a href="#3-7-代码高亮" class="headerlink" title="3.7 代码高亮"></a>3.7 代码高亮</h5><p>使用<a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener"> hexo-prism-plugin</a>的 Hexo 插件来加强代码高亮，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin</code></pre><p>修改 Hexo 根目录下 <code>_config.yml</code> 中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关配置，主要配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span>  custom_css<span class="token punctuation">:</span></code></pre><h5 id="3-8-搜索"><a href="#3-8-搜索" class="headerlink" title="3.8 搜索"></a>3.8 搜索</h5><p>使用  <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post</code></pre><h5 id="3-9-中文链接转拼音（可选的）"><a href="#3-9-中文链接转拼音（可选的）" class="headerlink" title="3.9 中文链接转拼音（可选的）"></a>3.9 中文链接转拼音（可选的）</h5><p>使用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment" spellcheck="true"># default: '-'</span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><p>3.10 文章字数统计插件（可选的）</p><p>安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件，在文章中显示文章字数、阅读时长信息，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h5 id="3-11-修改页脚"><a href="#3-11-修改页脚" class="headerlink" title="3.11 修改页脚"></a>3.11 修改页脚</h5><p>页脚信息可在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中定制化修改，包括站点、使用的主题、访问量等。</p><h5 id="3-12修改社交链接"><a href="#3-12修改社交链接" class="headerlink" title="3.12修改社交链接"></a>3.12修改社交链接</h5><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><h5 id="3-13-修改打赏的二维码图片"><a href="#3-13-修改打赏的二维码图片" class="headerlink" title="3.13 修改打赏的二维码图片"></a>3.13 修改打赏的二维码图片</h5><p>在主题文件的 <code>source/medias/reward</code> 文件中，替换成你的的微信和支付宝的打赏二维码图片。</p><h5 id="3-14配置音乐播放器（可选的）"><a href="#3-14配置音乐播放器（可选的）" class="headerlink" title="3.14配置音乐播放器（可选的）"></a>3.14配置音乐播放器（可选的）</h5><p>在主题的 <code>_config.yml</code> 配置文件中激活配置：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 是否在首页显示音乐.</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#非吸底模式 有效</span>   <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>   <span class="token key atrule">show</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">server</span><span class="token punctuation">:</span> netease   <span class="token comment" spellcheck="true">#必须    服务源: netease, tencent, kugou, xiami, baidu</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> playlist    <span class="token comment" spellcheck="true">#必须 歌曲, playlist, album, search, artist</span>  <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">260222983     </span><span class="token comment" spellcheck="true">#必须    歌曲 id / playlist id / album id / search keyword</span>  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> '<span class="token comment" spellcheck="true">#C4C4C4'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> all <span class="token comment" spellcheck="true"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'random'</span> <span class="token comment" spellcheck="true"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span> <span class="token comment" spellcheck="true"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.9 </span><span class="token comment" spellcheck="true"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 列表默认折叠</span>  <span class="token key atrule">listMaxHeight</span><span class="token punctuation">:</span> 600px <span class="token comment" spellcheck="true">#列表最大高度</span></code></pre><blockquote><p>防坑指南：主题默认开启歌词的，简单粗暴直接修改aplyer源码</p><pre><code>查找 aplayer-icon aplayer-icon-lrc 在后添加 aplayer-icon-lrc-inactivity查找 this.player.template.lrcButton.addEventListener 在前面添加 e.player.lrc.hide();</code></pre></blockquote><blockquote><p>防坑指南：主题最新播放器背景颜色和歌曲文章列表颜色相近导致看不清</p><p> 在/source/css/matery.css里添加如下：</p><pre><code>.aplayer-list-title {color: #666;}.aplayer-title {    color: #009688}</code></pre></blockquote><h5 id="3-15-文章-Front-matter-介绍"><a href="#3-15-文章-Front-matter-介绍" class="headerlink" title="3.15 文章 Front-matter 介绍"></a>3.15 文章 Front-matter 介绍</h5><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 、<code>categories</code> 、 <code>tags</code>、<code>date</code> 的值。</p><table><thead><tr><th align="left">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">title</td><td align="left"><code>Markdown</code> 的文件标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="left">date</td><td align="left">文件创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="left">author</td><td align="left">根 <code>_config.yml</code>中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="left">img</td><td align="left"><code>featureImages</code>中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="left">top</td><td align="left"><code>true</code></td><td align="left">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="left">cover</td><td align="left"><code>false</code></td><td align="left"><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="left">coverImg</td><td align="left">无</td><td align="left"><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="left">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="left">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="left">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="left">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="left">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="left">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><p>最简示例</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> hello world<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-02-10 08:05:00</span><span class="token key atrule">categories</span><span class="token punctuation">:</span> 杂文<span class="token key atrule">tags</span><span class="token punctuation">:</span> 测试<span class="token punctuation">---</span></code></pre><p>最全示例</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> hello world<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-02-10 08:05:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> athink_<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> 杂文<span class="token key atrule">tags</span><span class="token punctuation">:</span> 测试<span class="token punctuation">---</span></code></pre><h5 id="3-16-修改主题颜色"><a href="#3-16-修改主题颜色" class="headerlink" title="3.16 修改主题颜色"></a>3.16 修改主题颜色</h5><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre><code>/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}/*如果想去掉banner图的颜色渐变效果，请将以下的css属性注释掉或者删除掉即可*/@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><blockquote><p>推荐<a href="https://www.materialpalette.com/colors" target="_blank" rel="noopener">配色方案</a></p></blockquote><h5 id="3-17修改-banner-图和文章特色图"><a href="#3-17修改-banner-图和文章特色图" class="headerlink" title="3.17修改 banner 图和文章特色图"></a>3.17修改 banner 图和文章特色图</h5><p> banner 图修改在 /layout/_partial/bg-cover-content.ejs` 文件的代码中修改：</p><pre><code>$(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(/medias/banner/&#39; + new Date().getDay() + &#39;.jpg)&#39;);</code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h5 id="3-18-制作动态标题"><a href="#3-18-制作动态标题" class="headerlink" title="3.18 制作动态标题"></a>3.18 制作动态标题</h5><p>实现方法，引入js文件，在主题文件下的<code>/source/js/</code>下新建<code>FunnyTitle.js</code>，然后在添加到<code>themes/matery/layout/layout.ejs</code>或者添加到<code>themes/matery/layout/_partial/head.ejs</code>，其代码如下：</p><pre><code>&lt;!--浏览器搞笑标题--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&#39;visibilitychange&#39;, function () {     if (document.hidden) {         $(&#39;[rel=&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/favicon.png&quot;);         document.title = &#39;ヽ(●-`Д´-)ノ你要玩捉迷藏嘛&#39;;         clearTimeout(titleTime);     }     else {         $(&#39;[rel=&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/favicon.png&quot;);         document.title = &#39;ヾ(Ő∀Ő3)ノ好哦！&#39; + OriginTitle;         titleTime = setTimeout(function () {             document.title = OriginTitle;         }, 2000);     } });</code></pre><h5 id="3-19-添加动态诗词"><a href="#3-19-添加动态诗词" class="headerlink" title="3.19 添加动态诗词"></a>3.19 添加动态诗词</h5><p>在<code>/themes/matery/layout/_partial/head.ejs</code>添加下面的一行代码：</p><pre><code>&lt;script src=&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></pre><p>然后再将<code>/themes/matery/layout/_partial/bg-cover-content.ejs</code>中的<code>&lt;%= config.description %&gt;</code>修改为把<code>&lt;%= config.description %&gt;</code>改为<code>&lt;%- &#39;正在加载今日诗词....&#39; %&gt;</code>，这个使用前提是将主题配置文件的<code>subtitle</code>的值改为<code>false</code>。</p><h5 id="3-20-添加一言语录"><a href="#3-20-添加一言语录" class="headerlink" title="3.20 添加一言语录"></a>3.20 添加一言语录</h5><p>在<code>\layout\_widget\dream.ejs</code> 中修改如下</p><pre><code>&lt;div class=&quot;dream&quot;&gt;    &lt;% if (theme.dream.showTitle) { %&gt;    &lt;div class=&quot;title center-align&quot;&gt;       &lt;i class=&quot;fa fa-paper-plane&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &amp;nbsp;&amp;nbsp;&lt;%- theme.dream.title %&gt;    &lt;/div&gt;    &lt;% } %&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;!-- &lt;div class=&quot;col l8 offset-l2 m10 offset-m1 s10 offset-s1 center-align text&quot;&gt;            &lt;%- theme.dream.text %&gt;        &lt;/div&gt; --&gt;        &lt;div class=&quot;col l8 offset-l2 m10 offset-m1 s10 offset-s1 center-align text&quot;&gt;        &lt;/div&gt;        &lt;!-- 添加动态添加一言语录 --&gt;        &lt;% if (theme.dream.textUrl!=null||theme.dream.textUrl!=&quot;&quot;) { %&gt;            &lt;script&gt;                $.ajax({                    type: &quot;Get&quot;,                    url:  &quot;&lt;%- theme.dream.textUrl %&gt;&quot;,                    success: function(data) {                        $(&quot;.text&quot;).html(data)                    },                    error:function(){                        $(&quot;.text&quot;).html(&quot; &lt;%- theme.dream.text %&gt;&quot;)                         }                })            &lt;/script&gt;        &lt;% } %&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><blockquote><p>引用了 一言语录API : <a href="https://api.uixsj.cn/hitokoto/w.php" target="_blank" rel="noopener">https://api.uixsj.cn/hitokoto/w.php</a></p></blockquote><h5 id="3-21-鼠标点击文字特效"><a href="#3-21-鼠标点击文字特效" class="headerlink" title="3.21 鼠标点击文字特效"></a>3.21 鼠标点击文字特效</h5><p>实现方法，引入js文件，在主题文件下的<code>/source/js/</code>下新建<code>click_show_text.js</code>，并添加到<code>themes/matery/layout/layout.ejs</code>。其代码如下：</p><pre><code>var a_idx = 0;jQuery(document).ready(function ($) {    $(&quot;body&quot;).click(function (e) {        var a = new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);        var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]);        a_idx = (a_idx + 1) % a.length;        var x = e.pageX,            y = e.pageY;        $i.css({            &quot;z-index&quot;: 5,            &quot;top&quot;: y - 20,            &quot;left&quot;: x,            &quot;position&quot;: &quot;absolute&quot;,            &quot;font-weight&quot;: &quot;bold&quot;,            &quot;color&quot;: &quot;#FF0000&quot;        });        $(&quot;body&quot;).append($i);        $i.animate({                &quot;top&quot;: y - 180,                &quot;opacity&quot;: 0            },            3000,            function () {                $i.remove();            });    });    setTimeout(&#39;delay()&#39;, 2000);});function delay() {    $(&quot;.buryit&quot;).removeAttr(&quot;onclick&quot;);}</code></pre><h5 id="3-22-修改原有相册"><a href="#3-22-修改原有相册" class="headerlink" title="3.22. 修改原有相册"></a>3.22. 修改原有相册</h5><p>参考教程：<a href="https://liyangzone.com/2019/07/22/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BA%A7%E5%88%86%E7%B1%BB%E7%9B%B8%E5%86%8C/?spm=a2c4e.10696291.0.0.3f6a19a4hBRD5E" target="_blank" rel="noopener">传送门</a></p><h5 id="3-23-添加天气小插件"><a href="#3-23-添加天气小插件" class="headerlink" title="3.23. 添加天气小插件"></a>3.23. 添加天气小插件</h5><p>首先去中国天气官网：<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fcj.weather.com.cn%2Fplugin%2Fpc" target="_blank" rel="noopener">https://cj.weather.com.cn/plugin/pc</a>，配置自己的插件，选择自定义插件—&gt;自定义样式——&gt;生成代码，然后会生成一段代码，复制粘贴到 <code>themes/matery/layout/layout.ejs</code>即可。</p><h5 id="3-24-关于我页面添加个人简历"><a href="#3-24-关于我页面添加个人简历" class="headerlink" title="3.24. 关于我页面添加个人简历"></a>3.24. 关于我页面添加个人简历</h5><p>打开<code>theme/matery/layout/about.ejs</code>文件，大约在13行。有一个``标签，找出其对应结尾的标签，大约在61行左右，然后在新增如下代码：</p><pre><code>&lt;div class=&quot;card&quot;&gt;     &lt;div class=&quot;card-content&quot;&gt;         &lt;div class=&quot;card-content article-card-content&quot;&gt;             &lt;div class=&quot;title center-align&quot; data-aos=&quot;zoom-in-up&quot;&gt;                 &lt;i class=&quot;fa fa-address-book&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&lt;%- __(&#39;个人简历&#39;) %&gt;              &lt;/div&gt;                 &lt;div id=&quot;articleContent&quot; data-aos=&quot;fade-up&quot;&gt;                     &lt;%- page.content %&gt;                 &lt;/div&gt;           &lt;/div&gt;      &lt;/div&gt;&lt;/div&gt;</code></pre><p>注意粘贴的位置和空格要正确，这里的位置随你自己设置，你也可以把简历作为第一个card，然后<code>/source/about/index.md</code>下面写上你的简历了（就像写博客一样）。</p><h5 id="3-25外链跳转插件"><a href="#3-25外链跳转插件" class="headerlink" title="3.25外链跳转插件"></a>3.25外链跳转插件</h5><blockquote><p><a href="https://blog.hvnobug.com/go.html?url=aHR0cHM6Ly9naXRodWIuY29tL2h2bm9idWcvaGV4by1leHRlcm5hbC1saW5r" target="_blank" rel="noopener">hexo-external-link</a>是一个跳转外链相关插件。自动为所有html文件中外链的a标签生成对应的属性。 比如 设置<code>target=’_blank’, rel=’external nofollow noopener noreferrer’</code> 告诉搜索引擎这是外部链接,不要将该链接计入权重。 同时自动生成外链跳转页面,默认在根目录下 go.html;</p></blockquote><p>使用 npm 或者 yarn 安装</p><pre><code>## npm 安装npm install hexo-external-link --save## yarn 安装yarn add hexo-external-link</code></pre><p>之后再hexo博客站点根目录下添加如下配置：</p><pre><code>hexo_external_link:  enable: true  enable_base64_encode: true  url_param_name: &#39;u&#39;  html_file_name: &#39;go.html&#39;  target_blank: true  link_rel: &#39;external nofollow noopener noreferrer&#39;  domain: &#39;your_domain&#39; # 如果开启了防盗链  safety_chain: true</code></pre><ul><li><strong>enable</strong> - 是否开启<code>hexo_external_link</code>插件 - 默认 false</li><li><strong>enable_base64_encode</strong> - 是否对跳转<code>url</code>使用<code>base64编码</code> - 默认 fasle</li><li><strong>url_param_name</strong> - url参数名,在跳转到外链传递给<code>html_file_name</code>的参数名 - 默认 ‘u’</li><li><strong>html_file_name</strong> - 跳转到外链的页面文件路径 - 默认 ‘go.html’</li><li><strong>target_blank</strong> - 是否为外链的<code>a</code>标签添加<code>target=&#39;_blank&#39;</code> - 默认 true</li><li><strong>link_rel</strong> - 设置外链的<code>a</code>标签的rel属性 - 默认 ‘external nofollow noopener noreferrer’</li><li><strong>domain</strong> - 如果开启了防盗链,除了 localhost 和 domain 之外调用会跳到主页,同时也是判断链接是否为外链的依据 - 默认 window.location.host</li><li><strong>safety_chain</strong> - go.html 为了防止外链盗用 对域名进行的判断 - 默认 false</li></ul><p>3.24 添加雪花飘落效果</p><p>在<code>themes/matery/source/js</code>目录下新建<code>snow.js</code>文件，打开这个网址<a href="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/snow1.js" target="_blank" rel="noopener">传送门</a>，将内容复制粘贴到cursor.js即可。</p><p>然后再<code>themes/matery/layout/layout.ejs</code>文件内添加下面的内容：</p><pre><code>&lt;script src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;</code></pre><h5 id="3-25-添加自定义页面"><a href="#3-25-添加自定义页面" class="headerlink" title="3.25 添加自定义页面"></a>3.25 添加自定义页面</h5><p>首先在站点目录下的source文件夹下新建<code>aboutme</code>文件，文件名可自定义，然后编写一个<code>index.html</code>放入<code>aboutme</code>文件夹下，然后在主题配置文件下的导航配置信息添加下面的配置：</p><pre><code>About:    url: /    icon: fas fa-address-card    children:      - name: 关于我        url: /about        icon: fas fa-user-circle      - name: Another    #这是新添加的，在原有配置基础上添加        url: /aboutme        icon: fa fa-user-secret</code></pre><p>然后在站点配置文件下，找到<code>skip_render</code>，在后面添加属性，如下：</p><pre><code>skip_render: aboutme/**  # 其意思为在对文件进行渲染时跳过aboutme文件下的所有文件</code></pre><p>知道方法后，你可以添加你自己想要添加的页面，让你的博客内容更加充实。</p><h5 id="3-26-添加404页面"><a href="#3-26-添加404页面" class="headerlink" title="3.26 添加404页面"></a>3.26 添加404页面</h5><p>首先再站点根目录下的source文件夹下新建<code>404.md</code>文件，里面内容如下：</p><pre><code>---title: 404date: 2020-02-10 16:41:10type: &quot;404&quot;layout: &quot;404&quot;description: &quot;Oops～，我崩溃了！找不到你想要的页面了&quot;---</code></pre><p>紧接着再新建主题文件夹的layout目录下新建<code>404.ejs</code>文件，添加内容如下：</p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    /* don&#39;t remove. */    .about-cover {        height: 90.2vh;    }&lt;/style&gt;&lt;div class=&quot;bg-cover pd-header about-cover&quot;&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col s10 offset-s1 m8 offset-m2 l8 offset-l2&quot;&gt;                &lt;div class=&quot;brand&quot;&gt;                    &lt;div class=&quot;title center-align&quot;&gt;                        404                    &lt;/div&gt;                    &lt;div class=&quot;description center-align&quot;&gt;                        &lt;%= page.description %&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 每天切换 banner 图.  Switch banner image every day.    $(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(https://cdn.jsdelivr.net/gh/Yafine/cdn@2.6/source/medias/banner/&#39; + new Date().getDay() + &#39;.jpg)&#39;);&lt;/script&gt;</code></pre><h5 id="3-27-文章生成永久链接"><a href="#3-27-文章生成永久链接" class="headerlink" title="3.27 文章生成永久链接"></a>3.27 文章生成永久链接</h5><p>主题默认的文章链接配置是</p><pre><code>premalink: :year/:month/:day/:title</code></pre><p>这种生成的链接地址很长，文章版权的链接地址会出现一大串字符编码，一点也不好看。因此需要修改文章生成链接的格式。</p><p>首先再根目录下执行下面的命令：</p><p><a href="https%3A%2F%2Fgithub.com%2Frozbo%2Fhexo-abbrlink">hexo-abbrlinkGitHub地址</a></p><pre><code>npm install hexo-abbrlink --save</code></pre><p>然后再站点配置文件下添加如下配置：</p><pre><code>abbrlink:    alg: crc16   #算法： crc16(default) and crc32    rep: hex     #进制： dec(default) and hex: dec #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制</code></pre><p>再将站点配置文件的<code>permalink</code>的值修改为：</p><pre><code>permalink: posts/:abbrlink.html  # 此处可以自己设置，也可以直接使用 :/abbrlink</code></pre><p>生成文章的链接格式就会是如下样例（官方样例）:</p><pre><code>crc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.htmlcrc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html</code></pre><p>生成完后，原md文件的Front-matter 内会增加<code>abbrlink</code> 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p><h5 id="3-28添加Valine评论系统"><a href="#3-28添加Valine评论系统" class="headerlink" title="3.28添加Valine评论系统"></a>3.28添加Valine评论系统</h5><p>登录<a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">LeanCloud</a>,创建应用,在设置中将其中APPID和APPKey复制，添加到配置文件中。</p><pre><code>valine:  enable: false  # true即为开启评论系统  appId:   #此处填写你的appid  appKey:  #此处填写你的appkey  notify: false  verify: false  visitor: true  avatar: &#39;mm&#39; # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide  pageSize: 10  placeholder: &#39;just go go&#39; # Comment Box placeholder  background:  https://cdn.jsdelivr.net/gh/Yafine/cdn@2.6/social/comment_bg.png</code></pre><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><blockquote><p>本以为使用hexo开发博客会很复杂很难，</p><p>然而发现大多数都是写好的，只有在配置文件上修改就行,</p><p>对于主题样式内容等不满意再去打开源码修改就行，</p><p>其实只有会一点前端知识便可以对源码大概进行你想要的定制呢，</p><p>耐心的可以研究下主题构造也不错呢。</p><p>今天天气不错！加油！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好 hexo</title>
      <link href="/posts/509442df.html"/>
      <url>/posts/509442df.html</url>
      
        <content type="html"><![CDATA[<h2 id="你好-hexo"><a href="#你好-hexo" class="headerlink" title="你好 hexo"></a>你好 hexo</h2><blockquote><p>今天天气不错！！</p></blockquote><hr><h3 id="1-加油自己"><a href="#1-加油自己" class="headerlink" title="1.  加油自己"></a>1.  加油自己</h3><ul><li>今天天气不错！！</li><li>明天的你也要努力哦！</li><li>请一直加油下去哦！</li></ul><h3 id="2-一言语录"><a href="#2-一言语录" class="headerlink" title="2.  一言语录"></a>2.  一言语录</h3><blockquote><p>肌肤冰凉，寂静而干燥的空气，洗过的床单让气氛变得格外柔和，那个残忍的男子，说要让我再做一次美梦</p></blockquote><blockquote><p>正因为有了音乐，才有了相遇的瞬间，有了相会的感动，有了相逢的人们，有了邂逅的思念。</p></blockquote><blockquote><p>或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前路</p></blockquote><blockquote><p>仿佛要消失般的羸弱，但是，仍旧拼命绽放着光芒。怦怦，怦怦，如同心跳一般，这就是生命之灯</p></blockquote><blockquote><p>你的所言所行，全都闪烁着光芒，太过刺目，于是我闭上双眼，但内心还是无法停止对你的憧憬</p></blockquote><blockquote><p>车轮的金属音，不规则的足音，舌尖上面残留的淡淡红茶苦涩。平凡而无谓的对话，随处可见的风景。即使如此，却还是记得那么明晰。这一定，一定，是身处夏夜的错</p></blockquote><blockquote><p>四月是你的谎言，我知道…是谎言就一定会有被揭穿的时候。</p></blockquote><blockquote><p>继续踏上旅途，在没有你的春天</p></blockquote><blockquote><p>但是在喜欢和不讨厌之间，可是相隔了数亿光年都不止的距离啊！</p></blockquote><blockquote><p>英雄意味着强大，英雄意味着孤独，最后一幕一定是英雄渐行渐远，我的英雄也是那样的存在</p></blockquote><h3 id="3-未来可期"><a href="#3-未来可期" class="headerlink" title="3.未来可期"></a>3.未来可期</h3><pre class=" language-java"><code class="language-java">system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未来的你会感谢现在努力的你！加油！"</span><span class="token punctuation">)</span></code></pre><p><a href="https://imgchr.com/i/1vDjL8" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/15/1vDjL8.md.jpg" alt="1vDjL8.md.jpg"></a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
